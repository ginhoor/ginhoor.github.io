``` objc
/**

 无法通过[super respondsToSelector:aSelector]来检测对象是否从super继承了方法。

 因此调用[super respondsToSelector:aSelector]，相当于调用了[self respondsToSelector:aSelector]

 **/

- (BOOL)respondsToSelector:(SEL)aSelector

{

    BOOL result = [super respondsToSelector:aSelector];

    if (!result) {

        result = [self hasDelegateRespondsToSelector:aSelector];

    }

    return result;

}



/**

 在调用未实现方法时，会被调用。前置方法为resolve的两个方法。
 此方法还被用于当NSInvocation被创建的时候，比如在消息传递的时候。

 如果当前Classf可以处理未被直接实现的方法，则必须覆写此方法。

 */

- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector

{
    id delegate = [self delegateRespondsToSelector:aSelector];

    if (delegate) {

        return [delegate methodSignatureForSelector:aSelector];

    }

    return [super methodSignatureForSelector:aSelector];
}


/**
 无法识别的消息处理
 */
- (void)forwardInvocation:(NSInvocation *)anInvocation
{
    __block BOOL isExec = NO;
    
    NSMethodSignature *methodSignature = anInvocation.methodSignature;
    const char *returnType = methodSignature.methodReturnType;
    // 判断返回值类型
    if (0 == strcmp(returnType, @encode(void))) {
        [self notifySelectorOfAllDelegates:anInvocation.selector nofityHandler:^(id delegate) {
            [anInvocation invokeWithTarget:delegate];
            isExec = YES;
        }];
    } else if (0 == strcmp(returnType, @encode(BOOL))) {
        [self notifySelectorOfAllDelegateUntilSuccessed:anInvocation.selector defaultReturnValue:NO nofityHandler:^BOOL(id delegate) {
            
            [anInvocation invokeWithTarget:delegate];
            // 获得返回值
            NSUInteger returnValueLenth = anInvocation.methodSignature.methodReturnLength;
            BOOL *retValue = (BOOL *)malloc(returnValueLenth);
            [anInvocation getReturnValue:retValue];
            return *retValue;
        }];
    } else {
        // 等同于[self doesNotRecognizeSelector:anInvocation.selector];
        [super forwardInvocation:anInvocation];
    }
}
```

