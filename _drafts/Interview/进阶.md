
## 1. 网络
#### 1.1 HTTP协议、TCP/IP协议、Socket
  物理层-》数据链路层-》网络层-》传输层-》会话层-》表示层-》应用层
  #### HTTP协议属于应用层。
  1. HTTP协议定义了传输数据的使用方式。
  2. HTTP短连接是指以HTTP为通信协议的，请求一次即断开的TCP连接。
  3. HTTP长连接是指以HTTP为通信协议的，请求多次才断开的TCP连接。
  4. HTTP1.1协议以后，默认HTTP都是长连接。现在的网站多开启了Keep-Alive，用于保证连接在一段时间内不关闭，此时多个HTTP请求会走同一个TCP连接。
  5. HTTP 2.0（HTTPS）加入的SSL/TSL，带身份认证，传输数据用公钥加密，内容传输经过完整性校验。

  #### HTTPS的请求过程：
  1. 客户端发起HTTPS请求
  2. 服务端回传证书给客户端
  3. 客户端验证证书通过后生成随机秘钥，然后用证书中的公钥对此进行加密。
  4. 将加密后的随机值传输给服务端
  5. 服务端用私钥解密后得到随机值，然后在用随机值对要传输的信息进行加密。
  6. 服务端将信息传输给客户端。
  7. 客户端通过之前的随机值进行解密，获得解密内容。

#### TCP协议属于传输层。

  建立TCP协议需要**三次握手**：

    1. 客户端发送SYN包（SYN = 1 ，Seq序号 = X）给服务器，进入SYN_SEND状态，等待服务器确认；
    2. 服务器收到SYN包，必须确认用户的SYN（SYN = 1），生成一个Ack（Ack确认序号 = X + 1，Seq = Y），同时也发送一个确认包（SYN+ACK）给客户端，进入SYN_RECV状态。
    3. 客户端收到服务端的确认包（SYN+ACK），也向服务器发送确认包（Ack = Y+1，Seq = Z），此包发送完毕，客户端和服务端进入ESTABLEISHED状态，完成**三次握手**

  在双方任何一方未中断连接前，TCP连接将一直存在，客户端和服务端都可以主动发起断开TCP连接请求。

  实际情况是网络通信会经过很多中间节点，比如路由器、网关、防火墙，大部分防火墙会关闭长时间处于非活跃状态的连接而导致TCP连接中断，需要进行轮询保证连接状态处于活跃。

  断开TCP协议需要**四次握手**：

    1. 主动方发送一个FIN（FIN+ACK）包（FIN = 1，Ack = Z，Seq = X）给被动方，进入FIN_WAIT_1状态。
    2. 被动方收到FIN包后，发送一个确认包（Ack = X+1，Seq = Z）给主动方，被动方进入CLOSE_WAIT状态。
    3. 被动方发送FIN包（FIN = 1，Ack = X，Seq = Y），用来关闭数据连接，被动方进入LAST_ACK状态。
    4. 主动方收到FIN后，主动方进入TIME_WAIT状态，接着发送一个ACK（Ack = Y， Seq = X）包给被动方，被动方进入CLOSED状态。
#### IP协议

  IP协议属于网络层，用于定位网络上的一台设备。
#### UDP协议
  UDP协议可以直接向对方传输数据，而不需要建立连接，接收到数据也不发送确认信号，是一种无连接，不可靠的数据传输协议。UDP连接的开销更小，数据传输更快，实时性更好。
#### Socket连接
  Socket是一种实现方式，支持使用TCP协议或UDP协议进行网络连接。Socket是为了在多个应用或者多个TCP连接并发的时候做区分而产生的接口。
  Socket的建立过程：
  1. 服务端监听
  2. 客户端请求
  3. 连接确认
#### 三次握手，最后一次客户端对服务器的响应，如果失败了，服务器没有收到，会产生什么后果？
  服务器会处于TCP的半连接状态，不断重发确认包直至超时，会造成系统运行缓慢，或者网络拥堵。
  典型的DDOS攻击，攻击者通过短时间内伪造大量不存在的IP地址，不断给服务器发送SYN包。
#### 四次挥手，为什么断开连接是四次？而建立连接是三次？

  在三次握手时，服务端回传的确认包中包含SYN和ACK包，而断开连接时，被动方是先回传ACK包，再回传FIN包。
  在四次挥手时，当被动方收到主动方的FIN包时，主动方只是表达不在发送数据，但还是可以接受数据，所以此时被动方可能还会进行一些数据传输，所以多出了一个步骤。

#### 如何提网络连接速度

  减少TCP握手次数，使用HTTP长连接。
#### TCP拥塞控制，慢开始、拥塞避免、快重传和快恢复算法

  当某个时间段，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就会变坏，这就是拥塞。
  **慢开始算法**：发送端会根据接收端窗口大小，或者本身设置的慢开始阈值大小，两者取其小作为慢开始阈值，以渐进的方式控制发送的数据量，先探测一下网络的拥塞程度，由少变多的发送数据，直至同时发送数据量达到慢开始阈值大小。
  **拥塞避免算法**：在执行慢开始算法时，拥塞窗口成指数增加，达到慢开始阈值时，进入拥塞避免阶段，拥塞窗口按线性增加。当拥塞窗口达到一定程度时会发生拥塞(超时)，将慢开始阈值缩小到拥塞时的发送窗口大小的一半，再开始执行慢开始算法。 
  **快重传算法**：当接收端收到一个失序的数据包时，会立即发出重复确认，更早的通知发送端出现丢包。比如数据1和数据2被接收端成功接收并向发送端发送确认，数据3丢包，数据4被接受端接收，接收端会发出数据2的确认，当确认次数达到三次时，发送端会将数据3进行重传。
  **快恢复算法**：当发送端连续收到三个重复确认时，会将慢开始阈值会被缩小为发送窗口大小的一半，预防出现丢包。

#### HTTP的缓存策略

  iOS默认使用NSURLCache来操作HTTP缓存。
  1. 第一次Request发起后，如果请求成功，会根据收到的Response生成NSURLCachedResponse（在CachedResponse生成的回调中，可以自定义CachedResponse设置关联的data和userInfo），然后将CachedResponse存入缓存中，以Request作为索引。
  2. 第二次相同请求发起的时候，服务端判断没有数据更新，则会返回304的状态码，客户端则缓存中查询对应的Response。
  3. 默认策略下，客户端在发起请求时，会在Header中加上If-motified-Since字段告诉服务器数据的最后修改时间。
  4. 服务端在响应时，可以通过在Response的Header中加上Cache-Control字段来指定缓存策略
#### 1.2 DNS
  DNS的作用是将域名解析成IP。
  域名的结构：host.sld.tld.root（如：http://www.example.com）
  1. 所有的域名都在根域名下，真是的域名地址是http://www.example.com.root，即“.root”就是根域名。
  2. “.com”为顶级域名。
  3. “.example”为次级域名，这一级的域名是可以申请注册的。
  4. “www”为三级域名，可以由用户在自己配置，是用户为服务器分配的名字。

  DNS服务器根据域名的层级进行分级查询。查询时按根域名、顶级域名、次级域名、三级域名的顺序进行查找。
  DNS服务器会缓存下域名的查询结果，根域名的记录一般直接都缓存在DNS服务器中，根域名的DNS服务器一般不变。
#### HTTPDNS
  通过发起HTTP请求将域名解析成IP，获得IP后直接通过IP发起请求，不向本地运营商的LocalDNS发起domain查询，可以解决DNS劫持问题，一定程度上提升请求速度。
  iOS中，可以通过NSURLProtocol来拦截请求发起，然后通过HTTPDNS获得的IP，替换请求中的URL.host字段。

#### 1.3 NSURLCollection和NSURLSession的区别

  1. 普通请求和上传请求没有区别
  2. 下载请求有区别
      1. NSURLConnection是先将文件下载到内存中，再写入磁盘，会消耗内存。
      2. NSURLSessionDownloadTask是将文件写入磁盘临时文件中，在下载完成后临时文件会被删除 。
  3. 请求控制方法上NSURLSessionTask更容易管理。
      1. NSURLConnection的类方法在创建任务后立即开始请求，可以被取消，取消后本请求就不可再次使用。
      2. NSURLSessionTask的类方法在创建后处于挂起状态，不会开始请求，在唤醒后才开始请求。
  4. NSURLSesionDownloadTask提供了封装好的断点续传接口，可以通过ResumeData恢复任务。
      1. 需要响应Header中有“Accept-Range:bytes”字段，表示服务端允许对资源进行字节类型的访问。
      2. 在断点续传发起的时候，需要在请求Header中加入如“Range:bytes=1234567-”的字段，表明请求资源从字节1234567之后的部分。
  5. 与NSURLConnection相比，NSURLSession可以为每个Session配置单独的缓存，自定义协议，Cookie和身份认证策略，甚至跨程序使用。 
  6. NSURLConnectionDataDelegate的结束回调区分成功和失败两个，而NSURLSessionTaskDelegate在同一个回调中处理。
  7. NSURLSessionTaskDelegate增加了CompletionHandler参数，方便delegate处理参数。允许delegate可以安全地在主线程运行，而不会阻塞主线程。同时可以通过调用dispatch_async来使用后台线程进行操作，最后调用一次completionHandler就可以。
  8. NSURLSession的请求的配置更丰富。
      1. NSURLConnection的Request请求只能通过NSMutableRequest来配置
      2. NSURLSession可以通过SessionConfiguration来配置，增加了HTTPS设置，Cookie，指定网络连接类型，自定义协议，基础出站Header等。

#### NSURLSession优点

  1. 更成熟的任务管理方式。
  2. 更多的配置属性。
  3. 对HTTPS支持的完善。
  4. 使用了HTTP2.0协议，请求速度更快（HTTP2.0消息头的压缩算法采用HPACK）。
  5. 共享Session，可以减少TCP重复握手次数
#### AFNetworking的优点体现在哪里
  1. 提供Request的构造器，简化Request的参数配置；提供Response的解析器，方便响应数据的直接使用
      1. Request的GET请求Params会拼在URL上，POST请求的Params会放入HTTPBody。
      2. Response的结果可以被解析成XML，Property-List，JSON等。
  2. 为每一个网络请求都配置了单独的delegate，方便自定义数据处理。
## 2. 多线程
#### 2.1 线程和进程的区别是什么
  **进程**：通常一个应用只有一个进程，拥有独立的地址空间。一个进程崩溃不会引起系统的崩溃。
  **线程**：是在进程中创造出来的，没有独立的地址空间，只有自己的堆栈和局部变量。线程崩溃会导致整个进程崩溃。线程之间切换效率高于进程。
#### 多线程，多进程的优点
    1. 多进程可以提升系统的稳定性和运行效率，充分利用多核CPU。
    2. 多线程可以增加应用的运行效率，让耗时任务不会阻塞主线程的UI绘制。
#### 线程安全
  多个线程在运行的时候会同时对同一个资源进行读写，会出现不符合预期的现象。
  比如有两个线程在同时对同一个数组做删除和读取操作，读取操作的线程会因为读取了一个已经删除的对象而发生Crash。
  **解决方法**：对读写操作进行加锁。
#### 给线程加锁有哪几种方法
  1.@synchronized(token)
  2.NSLock
  3.GCD的信号量，dispatch_semaphore_t方法
  **性能消耗**：1 > 2 > 3
#### 两个进程如何实现通信
  1. Port (local socket)，NSMachPort->CFMatchPort->Match Ports。
    一个APP在本地端口发起TCP监听，另一个APP在同一个端口发起TCP连接，这样就可以建立Socket连接，但由于系统的限制，非前台的APP会在10分钟后被休眠。
  2. URL Scheme，比如使用淘宝客户端授权支付宝登录。
  3. KeyChain，通过指定KeyChain Access Group形式操作同一份数据，本质是一个sqlite数据库。
  4. UIPasteboard，剪切板。
  5. UIDocumentInteractionController，实现App之间共享文档。
  6. UIActivityViewController，比如微信分享
  6. App Groups，同一个开发团队的APP可以共享一份读写空间。
#### 2.2 NSThread、GCD、NSOperation
  1. NSThread是一个轻量化的库，未实现并发和队列。
  2. GCD基于C语言实现，提供队列，信号量的方法，效率更高，面向过程使用更方便。
  3. NSOperation是基于GCD的封装，设置线程依赖，队列并发数，队列挂起等功能更方便，适合用于复杂网络请求。
#### GCD和NSOpreation不同
  1. 相比于GCD，NSOperation可以用子类化的方式来管理任务，并可以控制队列并发数目。
  2. GCD只支持先进先出（FIFO）的队列，NSOperationQueue可以使用任务依赖来控制任务的执行顺序。
  3. GCD未实现任务依赖。
  4. NSOperationQueue可以知道当前正在运行的NSOperation，剩余还未完成的NSOperation，并可以用KVO的方式来监控NSOperation的状态。
#### GCD在使用中的注意事项
  1. 在使用sync任务时（在当前线程中创建当前线程的同步任务），不能让执行block的线程为当前线程，发生死锁
    在主线程调用同步任务
```objective-c
    {
        NSLog(@"1");
        //主队列的同步线程，按照FIFO的原则（先入先出），2排在3后面会等3执行完，但因为同步线程，3又要等2执行完，相互等待成为死锁。
        dispatch_sync(dispatch_get_main_queue(), ^{
            NSLog(@"2");
        });
        NSLog(@"3");
    }
```
  在串行队列里同步创建相同串行队列的同步任务。

```objective-c
    {
        dispatch_queue_t queue = dispatch_queue_create("test", DISPATCH_QUEUE_SERIAL);
        NSLog(@"1");
        dispatch_async(queue, ^{
            NSLog(@"2");
            dispatch_sync(queue, ^{
                NSLog(@"3");
            });
            NSLog(@"4");
        });
        NSLog(@"5");
    }
```
  **解决方法**：使用dispatch_queue_set_sepecific来标记queue，如果是相同队列在嵌套使用同步任务则抛出错误
  2. dispatch_barrier_async和dispatch_barrier_sync的注意事项
    不能使用全局并发队列dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)，而应当自己创建queue，也不应该使用同步队列，不然栅栏任务会变成一个普通的同步任务
#### GCD对线程执行队列排序

  可以，创建一个同步队列，在有依赖关系的任务之间插入一个异步的栅栏任务，可以保证他们的调用顺序。
#### fork创建线程和直接创建线程的区别
  1. fork的线程会完全复制父线程的资源，具有良好的并发性，但是开销大。
  2. 直接创建线程成本几乎就是线程任务的资源消耗。
## 3. 存储
#### 3.1 iOS数据持久化有哪些
  1. Plist
  2. CoreData(其实也是Sqlite)
  3. KeyChain
  4. Performence(UserDefault)
  5. Sqlite
#### 3.2 NSCache优于NSDictionary的几点
  1. NSCache可以维护缓存的空间占用大小，当内存不足时，系统会自动清理。
  2. NSCache是线程安全的。
  3. Key对象不会像NSMutableDictionay一样，被复制。

## 4.操作系统
#### 4.1 内存中堆与栈的区别

**栈**
  1. 由系统自动分配释放，速度加快，属于一级缓存。
  2. 用于短期存储数据，存储局部变量，函数参数，上下文等。
  3. 每条线程都会有自己的栈区
  4. 当剩余内存大于申请内存时，系统会为程序分配内存，否则会报栈溢出。
***
**堆**
  1. 手动申请，手动释放，由系统通过链表维护管理，所有程序共享的一块内存空间。一般速度较慢，容易产生内存碎片，属于二级缓存。
  2. 可以申请更大的空间，开销也更大。
***
**常量区**
  存放常量字符串。
***
**全局区（静态区）**
  .data：存放初始化过的全局变量和静态变量
  .bbs：存放未初始化的全局变量和静态变量。
***
**代码段区域**
  存放程序代码/指令
#### 4.3 内存分段与分页的区别
  **分段**和**分页**都是用虚拟地址空间来映射内存物理地址空间，区别是颗粒度不同。
  **分页**：页是数据的物理单位，大小是由系统决定的固定大小，分页是为了实现离散分配，提高内存的利用率。
  **分段**：段是数据的逻辑单位，可以在编译时候指定长度，保留部分逻辑特征，实现分段共享，分段的目的是操作内存。

#### 4.4 虚拟内存
    1. 用虚拟地址空间来映射内存物理地址空间，使内存可以被离散的使用，当内存不足的时候，部分旧的内存数据会放入到磁盘进行缓存。
    2. 虚拟内存地址空间可以大于物理内存地址空间。

#### 4.5 MMU内存管理单元

  CPU的MMU单元的作用是管理虚拟内存。
    1. MMU未启用的情况下，CPU查询的内存地址会直接对应到物理内存地址。
    2. MMU启用后，CPU查询的内存地址会被MMU截获，通过MMU的转换成物理内存地址，即CPU查询的内存地址实际为虚拟内存地址。
    3. MMU还有内存地址的权限管理功能，访问未授权的地址会返回错误，保护系统安全。
## 5. 编译
#### 5.1 Xcode编译原理
  编译过程：
  1. 预处理（Pre-process）：替换宏，删除注释，展开头文件，生成.i文件。
  2. 编译（Compliling）：把之前的.i文件转换成汇编语言，生成.s文件。
  3. 汇编（Asembly）：把汇编语言文件转换成机器码文件，生成.o文件。
  4. 链接（Link）：对.o文件中使用到的其他库进行引用，生成最后的多个可执行文件（同时也包括多个.o文件进行Link）。

  Xcode的编译过程可以通过**Build Phases**，**Build Rules**，**Build Settings**进行设定，这些设置都保存在工程文件.pbxproj

  **Build Phases**：设定从源文件到可执行文件的整个过程。比如设定需要编译的文件，在编译过程中执行的自定义脚本。

  **Build Rules**：设定编译某类型的源文件的方式。

  **Build Settings**：设定编译工作的细节，比如设置签名，是否使用ARC，H文件的搜索路径，指定PCH头文件路径，info.plist地址等。

#### 5.2 LLVM（Low Level Virtual Machine）底层编译器
  参考：[深入剖析-iOS-编译-Clang---LLVM](https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM)
  LLVM是一个模块化、可重用的编译器和工具链技术的集合，比GCC快3倍。
  Clang是LLVM的子项目，可以编译C、C++、Objectvice-C。
  编译信息写入辅助文件，创建文件架构 .app 文件
  编译过程
  1. 处理文件打包信息
  2. 执行 CocoaPod 编译前脚本，checkPods Manifest.lock
  3. 编译.m文件，使用 CompileC 和 clang 命令
  4. 链接需要的 Framework
  5. 编译 xib
  6. 拷贝 xib ，资源文件
  7. 编译 ImageAssets
  8. 处理 info.plist
  9. 执行 CocoaPod 脚本
  10. 拷贝标准库
  11. 创建 .app 文件和签名
#### 5.3 LLDB的使用

#### 5.4 iPhone 64位平台与32位平台

  1. 32位平台指针长度为4字节，64位平台指针长度为8字节
  2. 在32位平台中，指针长度与Int类型长度一致（均为4字节），可以互相转换，但64位架构中，指针长度为8字节，Int类型长度为4字节，强行转换会出现指针地址被截断。
  3. 要保证接收函数返回值的变量与函数返回值的类型相同，防止出现long类型返回值，被int变量接收，导致返回值被高位截断。
  4. 64位平台支持的最大内存地址比32位平台多。
