## UI

#### 自动布局（设置约束）和手动布局（设置frame）的优缺点，哪个效率高，为什么？
  1. 自动布局的约束条件属于相对布局，当布局结构发生变化的时候，可以减少修改的代码量
  2. 手动布局效率高，自动布局在渲染的时候，系统需要将约束解释成具体的坐标和宽高从而计算出Frame。
#### CALayer和UIView的区别
  1. UIView主要作用是处理响应量传递，侧重的是对内容的管理，CALayer主要作用是处理图像绘制
  2. 对独立创建，而非UIView自带的CALayer进行位置、背景色等的修改，会产生默认0.25秒的隐式动画，对UIView的位置、背景色等修改，则不会产生动画。
  3. CALayer维护者三部分的Layer Tree：PresentLayer Tree(动画树)，ModeLayer Tree(模型树)，Render Tree(渲染树)，对iOS动画的时候，在动画的其实是PresentLayer的属性值，而最终显示在界面上的是提供View的ModeLayer。
#### 使用Storyboard开发的利弊
  优点：
  1. 可以用UI的形式展现页面之间的跳转关系。
  2. 创建View便捷。
  3. 由Storyboard维护View的约束关系。

  缺点：
  1. Storyboard随着体积的增加，加载速度会变得很慢。
  2. Storyboard随着页面的增加，可维护性会变差，可复用性差，特别是出现文件冲突的时候。
  2. Storyboard会造成View的配置代码分散。

####AppDelegate的函数
```obj-c
// App第一次启动加载
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions

// App从后台恢复
- (void)applicationDidBecomeActive:(UIApplication *)application

// App即将进入后台
- (void)applicationWillEnterForeground:(UIApplication *)application

// App进入后台
- (void)applicationDidEnterBackground:(UIApplication *)application

// 当App从活跃状态转换成非活跃状态(锁屏幕，来电时候，也可能在切换入后台后调用)
- (void)applicationWillResignActive:(UIApplication *)application

// 当App被终止的时候
- (void)applicationWillTerminate:(UIApplication*)application
```

## 基础类型 

#### 对象（objc_object）的isa、类（objc_class）的isa、元类（metaclass）的isa
1. Class是一个指向**类结构体**的指针。
2. id是指向**对象结构体**的指针。
3. **对象结构体**的isa指向类结构体。
4. **类结构体**存放着成员变量和成员方法，**类结构体**的isa指向**元类结构体**。
5. **元类结构体**存放着全局变量和静态方法，**元类结构体**的isa指向**根元类结构体**，**根元类结构体**的isa指向自己，**根元类**的superClass指向**根类**

#### NSArray、NSSet、NSDictionary的效率

**NSArray**：有序存储集合。
**NSArray效率**：

1. 是否包含元素，查找对应Index的元素，需要遍历，为O(n)。
2. 删除为O(n)，需要遍历
3. 获取头部尾部元素，添加一个元素，移除最后一个元素为O(1)。
4. 二分法查找，为O(log n)。

**NSSet**：使用了哈希表，无序存储集合，且没有重复元素。

**NSSet效率**：

1. 添加、移除元素为O(1)。
2. 是否包含元素为O(1)。

**NSDictionary**：使用了哈希表，键值对集合。

**NSDictionary效率**

1. 添加、删除元素为O(1)
2. 查询为O(1)

#### NSHashTable与NSSet的区别

1. NSSet/NSMutableSet持有元素的强引用，通过`hash`与`isEqule:`方法来检测成员的散列值和相等性。
2. NSHashTable是可变的，没有不可变版本。
3. NSHashTable可以持有成员对象的弱引用，当对象被销毁的时候自动将其从集合中移除。
4. NSHashTable可以在加入成员时进行copy操作。
5. NSHashTable可以存储任意指针，通过指针来进行相等性和散列检查。

#### NSMapTable
1. NSDictionary/NSMutableDictionary会Copy对应的Key，强引用对应的Value。（NSMapTable可以设置成强引用Key，弱引用Value）
2. NSMapTable是可变的，没有不可变版本。
3. NSMapTable可以对其Key和Value进行弱引用，当Key或者Value被释放的时候，此成员会自动从NSMapTable中移除。
4. NSMapTable在加入Key-Value的时候，可以设置对成员的Value进行copy。
5. NSMapTable可以包含任意指针，使用指针进行相等性和散列检查。

#### Delegate与Block的区别
**Delegate**和**Block**一样都是一对一的回调。

**Delegate**
**优点**：

1. 运行成本低，只是指定了回调的实现。
2. 复杂逻辑实现时，可读性更高，适合重用。

**缺点**：当方法实现比较少的时候，也需要单独实现delegate，比较繁琐。

**Block**

**Block**捕获局部变量，是值传递，捕获静态变量或者全局变量，则是内存地址传递。

ARC中，**Block**有局部变量捕获是生成在堆，无局部变量捕获时生成在静态区。有一种特殊情况，生成了一个Block，但是未使用，则会生成在栈中。

MRC中，**Block**有局部变量捕获，并且为Copy的，生成在堆；有局部变量捕获，没有Copy的，生成在栈；没有局部变量捕获的，生成在静态区。

**Block**的优点：创建快速，使用方便。

**Block**的缺点：MRC的时候，Block是保存在栈内存的，出栈需要拷贝到堆内存。并且当**Block**使用完成或者设置nil后，才会回收。Block的实现不太容易重用。Block容易出现循环引用问题。

##### 什么时候用NS_OPTIONS，NS_ENUM?
NS_OPTIONS枚举值为NSInteger，NS_ENUM枚举值为NSUInteger；
NS_ENUM定义通用枚举，NS_OPTIONS定义位移枚举。

## Class
#### Category工作原理
  系统在运行时，会将Category整合到被扩展的类中，当发起消息时，系统就可以检测到Category中的函数。
  当有多个Category时，最后被编译的Category会被整合到类或者元类函数列表的最前面，所以最后被编译的Category中的方法会生效。在Build Phases -> Complie Source 中可以调整编译顺序。

#### @Property的实质是、常用关键字、@dynomic和@synthesize
  @Property的本质：生成ivar，getter和setter。
  常用关键字：weak、strong、assign、copy、noatomic、atomic等。
  **@dynomic**：声明getter和setter方法会在运行期生成，不需要自动生成。
  **@synthesize**：自动生成getter和setter方法。

#### @atomic与线程安全
  atomic只能确保当前property的setter和getter方法属于原子操作不受其他线程影响。
  当调用线程Agetter，B线程调用setter方法，C线程调用setter方法，线程A可能拿到B、C线程setter之前的值，也可能是B线程setter之后的值，也可能是C线程setter之后的值。

#### IBOutlet为什么是Weak引用的，ViewController中引用UIView应该用Strong还是Weak
  IBOutlet是由Storyboard创建的View，是直接加载到ViewController的View中的。ViewController强引用了它的View，IBOutlet的View又是存在View的subViews中的，所以ViewController的View对IBOutlet的View是强引用，所以当我们从ViewController中引用IBOutlet的View只需要Weak引用就可以了。
  在ViewController中引用UIView，使用Strong或者Weak都可以，因为引入的UIView不会强引用ViewController，所以不会引起引用循环。如果使用Weak方式引用UIView，一定要记得加入到ViewController的View中，不然会被提前释放。

## 通信机制

#### KVO、 KVC
  KVO：
  1. 基于runtime机制实现，当一个类的属性被第一次观察的时候，系统会动态的创建一个派生类，在这个派生类中重写被观察属性的setter方法中，值变化的代码前后加入通知机制，当调用setter方法修改值的时候，就会发出事件通知，观察者会接受到改变通知。
  2. 系统会将类的isa指针指向动态生成的派生类，从而当被监听属性调用的时候，会调用派生类的setter方法，激活键值通知机制。同时系统还会重写派生类的-(Class)class方法，让使用者将派生类当成原来的类使用。

  KVC：
  1. 使用字符串的形式访问对象，支持多层级访问（KeyPath），支持数组类型。
  2. 可以为私有属性，只读属性赋值。
  3. 支持集合操作符
    `@count`: 返回一个值为集合中对象总数的NSNumber对象。
    `@sum`:   首先把集合中的每个对象都转换为double类型，然后计算其总，最后返回一个值为这个总和的NSNumber对象。
    `@avg`:   首先把集合中的每个对象都转换为double类型，然后计算其均分，最后返回一个值为这个总和的NSNumber对象。
    `@max`:   使用compare:方法来确定最大值。所以为了让其正常工作，集合中所有的对象都必须支持和另一个对象的比较。
    `@min`:   和@max一样，但是返回的是集合中的最小值。
  4. KVC在赋值时会先查找setter方法；如果不存在setter方法，再查找实例变量；如果都不存在，则会调用`setVaue:forUndefinedKey:`方法，报出`NSUndefinedKeyException`异常并且Crash。
  5. KVC在取值时会先查找getter方法；如果不存在，再查询数组类型的查询元素方法；如果还不存在，则会搜索成员变量；如果获得到了指针，则直接返回；如果获得的是支持NSNumber类型，则包装成NSNumber返回，如果不是，则包装成NSValue返回。如果都不存在，则调用`valueForUndefinedKey:`方法。
    

  KVV：验证数据的有效性，但KVC不会主动调用。
```obj-c
  if ([self.contact validateName:&name error:&error]) {
  self.contact.name = name;
  } else {
  // Present the error to the user
  }
```
#### 事件传递及响应链
**事件传递**：
  1. 自上而下传递，如果父控件不能处理事件，则子控件也不能。例如在UIImageView中添加一个Button，Button将无法触发点击事件。
  2. 当触摸事件产生的时候，系统会将事件加入到一个由UIApplication管理的事件队列中，UIApplication会从队列中取出最早的事件，将事件发送给主窗口，Key Window再将事件根据层级传递到一个合适处理的View来处理触摸操作。
  3. View判断是否处理触摸事件
      1. 先判断自己能否处理触摸事件
      2. 再判断触摸点是否处于自己范围内
      3. 然后按子View层级，从上往下查询是否有可以处理事件的控件。如果有则往下传递，子View重复上述过程。
      4. 如果没有，则自己就是处理事件的View。

**响应链**
  1. 自下而上传递。只有集成了UIResponder的对象才能处理响应。
  2. 当前View为ViewController的View时，上一级响应者就是ViewController。当View不是ViewController的View时，上一级响应者是其父View。
  3. 当一个触摸事件传递到合适处理的View后，View会调用自己的触摸事件处理方法，系统默认的做法是在这个方法中调用上一级的处理方法，即View会将触摸事件的处理上抛给上一级。

## Runtime

#### Runtime原理

**Runtime**：在运行过程中完成类或者方法的实现。本质上OC的函数方法调用是向对应的类发送一个消息，只有在消息运行时才与函数实现进行绑定。

运行时，当系统发起objc_msgSend(obj,@selector(aaa:))的时候
1. objc_msgSend找到对象结构体。
2. 然后通过对象结构体的isa指针找到类结构体。
3. 在类结构体中查找对应的method，如果不存在则开始从SuperClass中查找。
4. 如果查找到结果，则将此方法加入缓存。

**对象关联**：
  1.主要应用是，使用Category进行类扩展的时候，添加关联对象。
  2.被关联对象的在生命周期内要比对象本身释放晚很多，他们会在NSObject -dealloc调用object-dispose()方法中才释放。
  3.删除属性的时候应当通过set方法传入一个nil值来清除关联。

**函数交换**：

  1. 可以在运行时替换函数实现，或者注入函数。
  2. 应当只在+load中完成，+load方法只在类被初次加载的时候调用。Swift中则需要在+initialize中实现，因为Swift不会调用+load方法。
  3. 应当只在dispatch_once中完成，确保只执行了一次。

**Weak对象管理**

  1. Weak对象被创建的时候会被加入到一个hash表中，将这个Weak对象的内存地址作为Key。
  2. 当Weak对象的引用计数为0时，系统会根据对象内存地址，查到这个Weak指针，将其置空。
  3. 所以向nil发送消息是安全的。

  详细过程
  1. 初始化时，Runtime会调用objc_initWeak函数，初始化一个weak指针指向对象内存地址
  2. 添加引用时，会调用objc_storeWeak()函数。先获得旧值和新值，以及旧值在表中的位置和新值在表中的位置，然后加锁，获得新对象的isa指针，调用对象的初始化方法，清除旧值，分配新值，然后解锁，返回新的对象。
  3. 当对象被release，并且引用计数为0，则调用dealloc对象，随后是\_objc_rootDeallc，object_dispose，objc_destructInstance，最后调用objc_clear_deallocating，从weak表中获得Key为当前对象内存地址的所有指针，赋值为nil，并将这条记录从weak表中删除。

**什么时候会报unrecognized selector错误**
  当系统运行时，调用函数，而函数并不存在的时候。
  调用对象函数，会先根据isa指针去查询其object_class,再通过object_class查找器method_list中是否存在对应函数，如果没有则查询其父类的method_list，如果都不存在，这回抛出unrecognized selector 错误。

**如何避免unrecognized selector错误**
  1. 实现动态方法抉择，当系统查询不到函数时，会调用对应Class的
    `+ (BOOL)resolveInstanceMethod:(SEL)sel`或者
    `+ (BOOL)resolveClassMethod:(SEL)sel`函数，
    在其中可以使用Runtime函数`class_addMethod`来添加缺失的函数，避免Crach，并返回YES。

  2. 只有当动态方法抉择返回NO的时候，才能使用消息转发。重写
    `- (void)forwardInvocation:(NSInvocation *)anInvocation`函数，定义转发逻辑，可以转发给不同的对象。同时需要重写
    `- (NSMethodSignature *)instanceMehodSignatureForSelectore:(SEL)sel`或
    `+ (NSMethodSignature *)methodSignatureForSelector:(SEL)sel`函数。
    在调用`- (void)forwardInvocation:(NSInvocation *)anInvocation`函数前，系统会先调用这两个函数取得签名用于生成NSInvocation对象。
    如果没有实现`- (void)forwardInvocation:(NSInvocation *)anInvocation`函数，
    则会进入`- (void)doesNotRecognizeSelector:(SEL)aSelector`函数，如果也没实现，则会崩溃。

  3. 在消息转发之前，系统会提供消息重定向的机会。
    重写`- (id)forwardingTargetForSelector:(SEL)sel`
    或者`+ (id)forwardingTargetForSelector:(SEL)sel`函数，将消息的接受者修改后返回。系统会向新的接受者发送消息。

**在运行时创建类**

```obj-c
// 创建一个继承NSObject的类，名字为mClass，类末尾字节分配为0；
Class mClass = objc_allocateClassPair([NSObject class],"mClass",0);
+ (void)createClass
{
    // 创建一个继承NSObject的类，名字为mClass，类末尾字节分配为0；
    Class mClass = objc_allocateClassPair([NSObject class],"mClass",0);
    
    // 为mClass添加一个NSString类型的变量personName。
    // 最后一位参数“@”表示，这个变量指向的是一个对象。
    /*   c A char
     i An int
     s A short
     l A long，l is treated as a 32-bit quantity on 64-bit programs.
     q A long long
     C An unsigned char
     I An unsigned int
     S An unsigned short
     L An unsigned long
     Q An unsigned long long
     f A float
     d A double
     B A C++ bool or a C99 _Bool
     v A void
     * A character string (char *)
     @ An object (whether statically typed or typed id)
     # A class object (Class)
     : A method selector (SEL)
     [array type] An array
     {name=type...} A structure
     (name=type...) A union
     bnum A bit field of num bits
     ^type A pointer to type
     ? An unknown type (among other things, this code is used for function pointers)
     */
    class_addIvar(mClass, "personName", sizeof(NSString *), 0, "@");
    // 添加一个方法，“v@:@”表示“v”：void返回值，“@”：self，“:”selector，“@”：对象类型参数
    class_addMethod(mClass, @selector(changePersonName:), (IMP)changePersonName, "v@:@");
    
    objc_registerClassPair(mClass);
    
    // 初始化对象
    id mPerson = [[mClass alloc] init];
    NSLog(@"mPerson:%@",mPerson);
    NSLog(@"1.personName：%@",[mPerson valueForKey:@"personName"]);
    
    [mPerson setValue:@"Tom" forKey:@"personName"];
    NSLog(@"2.personName：%@",[mPerson valueForKey:@"personName"]);
    
    [mPerson changePersonName:@"Roy"];
    NSLog(@"3.personName：%@",[mPerson valueForKey:@"personName"]);
    
    NSLog(@"****************");
    
    // 或者
    id mPerson2 = objc_msgSend(mClass, @selector(alloc));
    mPerson2 = objc_msgSend(mPerson2, @selector(init));
    NSLog(@"mPerson2：%@",mPerson2);
    NSLog(@"2.1.personName：%@",objc_getAssociatedObject(mPerson2, @"personName"));
   
    objc_setAssociatedObject(mPerson2, @"personName", @"Jim", OBJC_ASSOCIATION_COPY_NONATOMIC);
    NSLog(@"2.2.personName：%@",objc_getAssociatedObject(mPerson2, @"personName"));
    
    objc_msgSend(mPerson2, @selector(changePersonName:),@"Sam");
    NSLog(@"2.3.personName：%@",objc_getAssociatedObject(mPerson2, @"personName"));
    
    Ivar p_ivar = class_getInstanceVariable(mClass, "personName");
    NSString *personName = object_getIvar(mPerson2, p_ivar);
    NSLog(@"2.4.personName：%@",personName);
}

void changePersonName(id self, SEL cmd, NSString *newPersonName) {
    //获得类中的personName成员变量
    Ivar p_ivar = class_getInstanceVariable([self class], "personName");
    
    NSString *personName = object_getIvar(self, p_ivar);
    NSLog(@"personName-before->%@",personName);
    
    object_setIvar(self, p_ivar, [newPersonName copy]);
    NSLog(@"newPersonName-->%@",newPersonName);

    personName = object_getIvar(self, p_ivar);
    NSLog(@"personName-after->%@",personName);
    
    
}
// 必须实现方法，不然方法不会被加入到method_list
- (void)changePersonName:(NSString *)newPerson
{
    
}

打印结果：
mPerson:<mClass: 0x6000009c0270>
1.personName：(null)
2.personName：Tom
personName-before->Tom
newPersonName-->Roy
personName-after->Roy
3.personName：Roy

****************

mPerson2：<mClass: 0x6000009c8ed0>
2.1.personName：(null)
2.2.personName：Jim
personName-before->(null)
newPersonName-->Sam
personName-after->Sam
2.3.personName：Jim
2.4.personName：Sam

```
  从打印结果可以看出，关联对象的使用与KVC的使用相同，而对关联对象进行赋值，并不会改变对应的iVar，反之亦然。
***
**运行时为创建的类添加property**

```obj-c
+ (void)createProperty
{
    Class mClass = objc_allocateClassPair([NSObject class], "testClass", 0);
    objc_registerClassPair(mClass);
    
    /*
     R The property is read-only (readonly).
     C The property is a copy of the value last assigned (copy).
     & The property is a reference to the value last assigned (retain).
     N The property is non-atomic (nonatomic).
     G<name> The property defines a custom getter selector name. The name follows the G (for example, GcustomGetter,).
     S<name> The property defines a custom setter selector name. The name follows the S (for example, ScustomSetter:,).
     D The property is dynamic (@dynamic).
     W The property is a weak reference (__weak).
     P The property is eligible for garbage collection.
     t<encoding> Specifies the type using old-style encoding.
     */
    //设置类型
    objc_property_attribute_t attribute1;
    attribute1.name = "T";
    attribute1.value = @encode(NSString *);
    
    // 设置nonatomic
    objc_property_attribute_t attribute2 = {"N",""};
    // 设置copy
    objc_property_attribute_t attribute3 = {"C",""};
    // 设置对应的ivar名称
    objc_property_attribute_t attribute4 = {"V","_personName"};
    
    objc_property_attribute_t attributes[] = {attribute1,attribute2,attribute3,attribute4};
    
    class_addProperty(mClass, "personName", attributes, 4);
    
    unsigned int count;
    objc_property_t *list = class_copyPropertyList(mClass, &count);
    
    for (int i = 0; i < count; i++) {
        objc_property_t property = list[i];
        const char *str = property_getName(property);
        
        NSLog(@"%s",str);
    }
    
}
```
  为一个类添加一个属性后，类的ivar_list会增加，实例的内存大小也会增加，

***
**能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？**
  1.不能向编译后的类中增加变量，编译后的类已经注册在rumtime中，类结构的objc_ivar_list实例变量列表和instance_size实例变量内存大小已经确定，同时会调用class_setIvarLayout或class_setWeakIvarLayout来处理strong、weak引用。
  2.可以向运行时创建的类添加实例变量，调用class_addIvar函数来添加，但是要在调用objc_allocateClassPair之后，在objc_registerClassPair之前。



##内存管理
##### iOS可能出现的内存泄露
  1. block循环引用
  2. 关联对象未合理释放
  3. 定时器的释放放在dealloc中
  4. 非OC对象的内存处理。
  5. 用循环创建大量临时对象时（手动加入@autorealasepool管理）