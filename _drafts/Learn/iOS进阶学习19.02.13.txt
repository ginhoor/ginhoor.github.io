1. 网络

1.1 HTTP协议、TCP/IP协议、Socket

HTTP协议属于应用层。
    HTTP协议是TCP协议的一种实现，定义了传输数据的使用方式。
    HTTP协议多作为短连接使用，一次请求获得一次响应。
    HTTP也可以作为长连接使用，发一次请求，后保持连接，然后重复请求，获得响应。

HTTPS的请求过程
    客户端发起请求
    服务端接受到请求，并回应证书链
    客户端收到证书链，验证域名、公钥、有效期等信息，验证通过后客户端生成随机码，并用证书中的公钥对随机码进行加密，传给服务端。
    服务端收到随机码后用私钥进行解密，获得随机码。
    服务端将数据用随机码加密，回传给客户端。
    客户端收到数据后用随机码进行解密，获得数据。

TCP协议属于传输层。
TCP协议偏重于保证数据的完整性，建立连接需要通过三次握手，取消连接需要通过四次挥手。
TCP的三次握手
    1.客户端发起连接SYN包，等待服务器确认。
    2.服务端收到SYN包，验证用户通过后，生成ACK包，回传客户端确认包（SYN+ACK）。
    3.客户端接收到确认包（SYN+ACK），也向服务端发送确认包，连接建立完成。

TCP的四次挥手
    1.主动方发起FIN+ACK请求包，等待被动方确认。
    2.被动方收到FIN请求包后，先回传一个ACK确认包。
    3.被动方再发送一个FIN+ACK的请求包，表示关闭数据连接，并等待确认。
    4.主动方收到FIN包，再发送一个ACK给被动方，并关闭数据连接。

IP协议
    IP协议用于定义设备在网络中的身份地址。

UDP协议
    UDP协议偏重于数据的传输速度，UDP连接不需要预先建立，可以直接发送数据，开销更小，速度更快，实时性好。

Socket连接
    Socket连接是一种具体实现方式，可以使用TCP协议或者UDP协议，使用时接收端先开始监听，发送端再发送数据，就可以达到传输目的，可以实现双向传输。 

三次握手，最后一次客户端对服务器的响应，如果失败了，服务器没有收到，会产生什么后果？
    服务端会一直等待连接确认响应，直至超时。
    短时间内收到大量的SYN包，会使服务器运行缓慢，或者网络堵塞

四次挥手，为什么断开连接是四次？而建立连接是三次？
    建立连接服务端的确认包中包含SYN和ACK包，而断开连接时，被动方是先回传ACK包，再回传FIN包。
    因为当被动方收到主动方的FIN包时，主动方只是表达不在发送数据，但还是可以接受数据，所以此时被动方可能还会进行一些数据传输，所以多出了一个步骤。

如何提网络连接速度
    合并或者减少请求，保持长连接，减少网络请求建立次数。
    减少数据量。

TCP网络控制
慢开始
    发送端取接收端窗口大小或者本身设置的阈值大小其中较小值来设置拥堵窗口，采用渐进式控制发送的数据量，直到发送数据量达到拥堵窗口阈值
拥塞避免
    当网络达到慢开始阈值后，慢开始阈值会被缩小为发送窗口大小的一半，再重新执行慢开始
快重传
    当接收端接收到一个失序的数据包，会立即发出失序的包之前的包的确认包，当发出的重复确认包达到3次时，发送端会重新发送丢失的数据包。
快恢复
    当出现了三次重复确认包的情况时，会将慢开始阈值会被缩小为发送窗口大小的一半，预防出现丢包。


HTTP的缓存策略
    
    iOS默认用NSURLCache来缓存HTTP请求。
    第一次请求，当Request请求成功后，返回的Response会被存储到hash表中，以Request为索引，当进行了自定义后，可以在获取到Response的时候进行关联userInfo或者data的自定义处理。
    第二次请求，当Request发起后，服务端判断没有数据更新，则会返回304状态码，客户端则从缓存中查询对应的Response。

    默认策略下，客户端在发起请求时，会在Header中加上If-motified-Since字段告诉服务器数据的最后修改时间。
    服务端在响应式，可以通过在Response的Header中加上Cache-Control字段来指定缓存策略


1.2 DNS
    DNS是将域名解析成IP地址查询服务，根据域名的层级进行顺序查询，每次一查询的结果都会缓存在DNS服务器中，定时更新。

    HTTPDNS
    通过HTTP请求来解析域名，再通过IP直接发起请求
    iOS中可以通过NSURLProtocal来拦截请求发起，通过HTTPDNS解析域名后，替换URL的host字段。

1.3 NSURLCollection和NSURLSession的区别
    
    两者的普通请求和上传请求没有区别
    在下载请求方面，NSURLCollection是先将数据下载到内存，再移入磁盘。NSURLSession则是将数据直接下载如硬盘临时文件，下载完成后会删除临时文件。

    NSURLSession增加了断点续传功能，只需要服务端 Response Header中有Accepted-Range:bytes字段。

    NSURLSession比NSURLCollection更容易控制管理，NSURLCollection在创建请求后，会立即执行，而NSURLSession在创建后任务会先进入挂起状态，在唤醒后才会执行。

    NSURLSession可以为每一个实例配置单独的缓存策略，身份认证策略，协议等。

    NSURLCollection的Delegate区分成功和失败回调，NSURLSession不区分。

    NSURLSessionTaskDelegate添加了CompletionHandler参数，方便delegate处理参数

    NSURLSession配置请求更丰富，可以通过SessionConfiguration来配置HTTPS，Cookie，网络连接类型，出站基础Header等，而NSURLCollection只能通过NSMutableRequest来配置。

NSURLSession优点
    更方便的管理网络任务队列
    更多的可配属性
    共享Session，减少TCP重复握手次数
    对HTTPS支持更完善
    使用HTTP2.0协议，请求速度更快
    
AFNetworking的优点体现在哪里
    1. 提供Request的构造器，简化Request的参数配置；提供Response的解析器，方便响应数据的直接使用
    2. 为每一个网络请求都配置了单独的delegate，方便自定义数据处理


2. 多线程
2.1 线程和进程的区别是什么
    一个系统中可以存在多个进程，一个进程中可以存在多个进程
    一个进程的崩溃不会引起系统崩溃，一个线程的崩溃会引起进程的崩溃。
    进程拥有独立的地址空间，线程没有，线程之间的切换效率高于进程

多线程，多进程的优点
    多进程可以提升系统的稳定性和运行效率，充分利用多核CPU
    多线程可以增加应用的运行效率，让耗时任务不阻塞主线程

线程安全
    多个线程对同一资源进行读写的时候可能会出现不符合预期的现象。

给线程加锁有哪几种方法
    @synchronized
    NSLOCK
    GCD信号量

两个进程如何实现通信
    通过local socket建立TCP链接进行短暂通信。
    URL Scheme
    APP Groups
    Keychain
    UIActivityViewController
    UIPasteboard
    UIDocumentInteractionController

2.2 NSThread、GCD、NSOperation
    1. NSThread是一个轻量化的库，未实现并发和队列。
    2. GCD基于C语言实现，提供队列，信号量的方法，效率更高，面向过程使用更方便。
    3. NSOperation是基于GCD的封装，设置线程依赖，队列并发数，队列挂起等功能更方便，适合用于复杂网络请求。

GCD和NSOpreation不同
    GCD多为面向过程使用，NSOperation多为面向业务使用。
    NSOperation可以使用子类化来管理任务，并且可以控制队列并发数目。
    GCD的队列只支持先进先出，NSOperationQueue可以使用任务依赖来控制任务的执行顺序。
    NSOperationQueue可以通过KVO来监控当前任务的执行状态。

GCD在使用中的注意事项
    不能在当前线程中创建当前线程的同步任务。
    不能在串行队列中创建串行队列的同步任务。

GCD对线程执行队列排序
    在有依赖的任务后插入栅栏来控制任务执行顺序

fork创建线程和直接创建线程的区别
    fork的线程会完全复制父线程的资源，但是开销大
    直接创建线程无消耗。

3. 存储

3.1 iOS数据持久化有哪些
    plist
    keychain
    coredata
    performance
    sqlite

3.2 NSCache优于NSDictionary的几点
    NSCache可以定义存储方式、存储空间大小、内存不足时会被清理
    NSCache是线程安全的
    Key对象不会像NSMutableDictionary一样被复制。

4.操作系统

4.1 内存中堆与栈的区别
    栈中的数据是系统自动分配的，每个线程有自己独立的栈区，用于短期存储，比如局部变量，函数参数，上下文等。空间有限。

    堆中的数据是手动申请，手动释放的，由系统通过链表维护，所有程序共享。容易产生内存碎片。空间较大，申请开销也大。

    常量区存储的是常量字符串
    全局区中存储的是全局变量和静态变量。
    .data 存储的是初始化过的变量。
    .bbs 存储的是未初始化的变量。

    代码区存储的是程序代码

4.3 内存分段与分页的区别
    分页和分段都是用虚拟地址空间来映射物理内存空间，颗粒度不同。
    页是数据的物理单位，大小由系统确定，分页是为了实现离散分配。
    段是数据的逻辑单位，可以在编译时指定长度，保留部分逻辑特征，实现分段共享。

4.4 虚拟内存
    用虚拟内存地址空间来映射物理内存地址空间，使内存可以离散使用，当内存不足时，旧数据会被缓存到磁盘中，虚拟内存空间可以大于物理内存空间。

4.5 MMU内存管理单元
    MMU是CPU管理虚拟内存的模块
    当MMU未启用的时候，CPU查询的内存地址直接对应物理内存地址。
    当MMU启用的时候，CPU查询的内存地址会被MMU截获并映射到对应的物理内存地址，即现在CPU使用的是虚拟内存地址。
    MMU还有内存地址的管理权限，访问未授权的地址会返回错误。

5. 编译

5.1 Xcode编译原理
    预处理，处理宏，删除注释，展开头文件
    编译，将代码编译成汇编代码
    汇编，将代码编译成机器代码
    链接，加入库引用，生成执行文件


5.2 LLVM（Low Level Virtual Machine）底层编译器
    
5.3 LLDB的使用

5.4iPhone 64位平台与32位平台
