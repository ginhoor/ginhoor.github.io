UI

自动布局（设置约束）和手动布局（设置frame）的优缺点，哪个效率高，为什么？
自动布局使用的是相对布局，布局结构改变时，减少修改的代码量
手动布局效率高。自动布局在实现的时候会先转换成frame，如果条件复杂，这需要消耗更多的性能


CALayer和UIView的区别
CALayer是图形绘制的基础控件，可以控制动画，渲染方式，绘制缓存。
UIView是为了传递响应链，响应链从下至上处理事件。

使用Storyboard开发的利弊
Storyboard中可以添加多个ViewController，并且复杂度较高，当多人同时开发的时候，冲突很难解决。
复用性不高，造成UI代码和UI设置分散

AppDelegate的函数
AppDelegate负责应用的各种状态
比如进入后台，应用唤醒，应用从url跳转，应用的推送接收

基础类型

对象（objc_object）的isa、类（objc_class）的isa、元类（metaclass）的isa

对象的isa指向类结构体，类的isa指向元类，元类的isa指向根元类，根元类的isa指向他自己。

对象结构体中objc_object包含了成员变量和成员方法，obj_class包含了全局变量、静态变量和类方法。


NSArray、NSSet、NSDictionary的效率
NSArray的查询复杂度是O（n），如果是二分法查找，则是O（log n），NSArray是有序集合
NSSet的存储是离散的，并且不存在重复，查询单个元素是否存在复杂度为O（1）。
NSDictionary的存储也是离散的，可以指定Key。


Delegate与Block的区别

Delegate和Block都是一对一的，delegate可以使用子类化，Block不可以。

Delegate可以解耦代码，Block不可以。
Block容易引起循环引用问题。


什么时候用NS_OPTIONS，NS_ENUM?
NSOpetions 定义位移枚举。
NSEnum 定义通用枚举。


Class


Category工作原理
Category的原理是在运行时，系统会将扩展的方法加入或者替换到类的方法列表中，越后编译的category会被放在越前面，则会先生效。


@Property的实质是、常用关键字、@dynomic和@synthesize

property的实质是生成了setter和getter两个方法，外加一个ivar指针
常用的有weak，strong，copy，noatomic
@dynomic指setter和getter方法在运行时生成
@synthesize指setter和getter由系统生成

@atomic与线程安全
@atomic只能保证property的setter和getter方法是加锁操作，但是不能保证整个对象是线程安全的


IBOutlet为什么是Weak引用的，ViewController中引用UIView应该用Strong还是Weak
因为view在创建后被加入到VC的view中，被View强引用，所以VC不需要强引用View。

通信机制

KVO、 KVC
KVO的实质是系统为被观察的对象创建了一个新的类，在这个类的被观察property的setter中插入了监控值变化的代码。但系统会隐藏这个，将这个类的meta class指向原来的类。

KVC是key value coding，只通过字符串来访问对象属性，可以为只读属性或者私有属性赋值，支持多级访问，集合操作。
集合操作符@count，@sum，@max，@min，@avg
KVC会先查找setter或者getter方法，再查找实例变量


事件传递及响应链
事件的传递自上而下，事件从window传入，先判断window是否处理事件，再判断vc是否处理事件，再判断View，逐级递进。
响应链的传递是自下而上的，先由响应的responder判断是否传递，然后传递给他的父级，再是VC


Runtime

Runtime原理

Runtime是在运行时创建类，添加类成员或类方法，替换方法实现，添加对象关联等

对象关联，可以在运行时为category创建成员变量，但是关联对象的释放时间会晚于对象的dealloc，只有当NSObject调用dealloc的时候才会释放。

替换方法实现需要注意只调用一次


weak对象的管理，系统会维护一个hash表来存储weak对象，当对象的引用计数为0的时候，系统会将对应的weak对象设置为nil。


当系统调用方法是，首先是objc_msgSend声明调用对象和调用方法，然后对象结构体，再通过对象结构体的isa指针找到类结构体，在类结构体的methodList中查找对应的方法，如果不存在，再查找superClass，如果存在，则将此方法加入缓存。

当出现unrecognized selector错误时，当系统无法查找到对应函数的时候。
可以在动态方法抉择的时候，为异常函数请求做重定向或者动态的为class来添加这个方法，避免crash。
运行时创建类可以添加变量和方法。
不能像编译后的class添加实例变量，因为class的内存分配已经完成，无法修改。



内存管理


iOS可能出现的内存泄露
block循环引用
关联对象未释放
定时器未释放
非OC对象的内存处理
在一个循环内大量读取数据



列表优化
减少透明度使用
增加列表的layer重用
减少view层级
缓存列表高度计算



离屏渲染
离屏渲染是指开辟一块新的区域约两倍屏幕的大小，用来处理渲染。
当发生离屏渲染时，当前绘制上下文会先切换到离屏，然后绘制完成后，再将切换上下文到当前屏，将缓存内容渲染到屏幕上。

DrawRect
CPU渲染

栅格化
缓存绘制内容，当内容没有发生变化的情况下，会不会重新绘制

mask
shadow
groupOpacity
coretext
cpu绘制
渐变


解决方案：
尽量只在某些绘图在比如动画这种场景下需要重复使用，才使用栅格化

当出现性能问题的时候，先判断是CPU瓶颈还是GPU瓶颈，再决定用什么渲染方式。
可以使用mask遮罩来实现圆角，而不是直接设置圆角。



