[移动客户端中高效使用 SQLite](https://cloud.tencent.com/developer/article/1071458)

## SQLite 初始化
#### 1.设置合理的 page_size 和 cache_size

可能影响page_size和cache_size的三个因素

1. table_size
2. 存储的数据类型
3. 增删改查比例

page_size的增加对于数据库查询的优化，优于插入操作的优化。


当插入数据量较小时，反而晓得page_size和cache_size更有优势，但是当App DB耗时更多的体现在大量数据增删改查的时候，适合用稍大的page_size。

设置page_size的两种方法

1. 数据库创建时
2. 数据库已经初始化，调用`vacuum`对数据表的节点重新计算分配大小。


#### 2.通过timer来控制数据库事务定时提交
一个Transaction可以大幅度提升其内部的增删改查速度，官方文档显示可以提升性能两个数量级以上。

通过创建一个Timer来循环执行“提交任务，并启动一个新事务”的任务。

注意：当两份数据拥有依赖关系，需要同时被写入、删除、修改时，定时提交事务可能引发两份数据操作进入不同的事务，而第二个事务无法正确提交。可以用SQLite的事务嵌套共轭能来解决，让内层事务保证多份数据的完整性。

#### 3.缓存编译后的SQL语句
SQL String是需要编译后才能被执行的，一次编译时间根据复杂程度从几毫秒到十几毫秒不等，对于批量操作的性能优化极其明显。

#### 4.数据库完整性校验
移动客户端的数据库可能因为各种原因造成数据库损坏。

1. 掉电
2. 后台被挂起
3. 进程被kill
4. 磁盘空间不足


SQLite提供了检测数据库完整性的命令`PRAGMA integrity_check`，该语句返回结果不是OK，则意味着数据库损坏。程序可以通过ROLLBACK到一个旧版本等方法来解决数据库损坏带来的不稳定性。


#### 5.数据库升级逻辑
SQLie在内部有一张meta表专门记录数据库的当前版本号、最低兼容版本号等信息。
当V2版本的表结构与V1版本不同是，我们需要根据当前数据库版本进行处理，V1版本的数据库需要升级表结构，升级完毕后更新数据库的版本。


## 高效的SQL语句

#### 1.建立索引（covering index & explain query）
借助SQLite提供的explain query工具（EXPLAIN QUERY PLAN），可以看出一条查询语句在数据库内部是如何执行的。

一条查询语句的执行方式有很多种，可能会扫描整张数据表，可能会扫描主键子表，可能会扫描索引子表，或者这些方式组合。

针对某列建立索引，就是将这列数据和主键数据全部取出。以索引列为主键升序，原表主键为第二列，重新创建一张新表。

注意：针对多列简历索引的SQLite内部实现方案：索引第一列作为主键升序，第一列排序完毕后，索引第二列升序（主键相同的数据做排序），以此类推，最后以原表主键作为最后一列。这样能保证每一行数据都不完全相同，这种多列建索引的方式也叫COVERING INDEX。

如果排序列没有建立索引，SQLite内部会建一个临时的B-Tree来进行排序。所以对于Order By的列，最好事先做索引。

**建索引的方式可以提升搜索性能，但是对数据库初始化性能有非常大的负面影响**

优化方向

1. 减少扫描数据表的次数
2. 尽量扫描索引表而不是原始表
3. 做好与数据库体积的平衡


#### 2.先建立原始表再建立索引 （insert first then index）

XCode Instrument 统计十万条数据插入，对比“先建立原始表，再建立索引”与“同时插入数据和建立索引”，前者CPU耗时降低了20%。

**原因：**

数据库的增删改查其实都需要用到公共的一个操作就是搜索查找到对应的树节点。从磁盘读取索引表的一个节点到内存，再从内存判断这个节点是否有对应的key，或者判断节点是否需要合并或分裂。

磁盘获取下一个节点的耗时比内存中各项操作的耗时多好几个数量级，也就是说对索引表的各项操作，增删改查的耗时取决于磁盘获取节点的时间。

一边插入原始表的数据，一边插入索引表的数据，可能造成由于缓存空间减少，索引表节点需要频繁从磁盘读取，增加了从磁盘获取节点的次数。而只进行索引插入操作，系统缓存节点的量将增加，命中率提高后速度也就提升了。

SQLite内部是以B-Tree的形式组织的，一个树节点一般对应一个page。

log[m/2]（1+(N+1)/2）

公式中的m就是B-Tree的阶数，也就是节点中最大可存放关键字数+1。也就是说m与page_size成正比，与复杂度成反比，与树的高度成反比，与读取磁盘次数成反比，与耗时成反比。

所以增加page_size确实可以减少SQLite的查询类操作。但是无限制的增加Page_size会使节点内数据过多，节点内的数据查询退化成线性二分查询，复杂度反而上升。

#### 3.SELECT then INSERT or UPDATE 与 INSERT OR REPLACE INTO
当维护数据库数据时，经常出现需要用新数据代替已存在老数据的情况。

INSERT OR REPLACE INTO的原理是，通过主键查询对应行是否存在，如果存在，先删除老数据，再插入新数据。

SELECT then INSERT or UPDATE
先手动通过主键查询对应行是否存在，如果存在，则使用UPDATE来更新数据，如果不存在则使用INSERT。

从逻辑上来看，INSERT OR REPLACE INTO可以将原来的三条查询语句减少为一条，更方便。从性能上来看，SELECT then INSERT or UPDATE在数据更新时有更好的效果。

#### 4.Full Text Search（FTS）
FTS是SQLite为了加快字符串搜索而创建的虚拟表。

FTS不仅能通过分词加快英文类字符串的搜索，对于中文字符串，配合ICU也能对中文进行分词。

#### 5.个数不固定的元素集合不要分表
在设计数据库的时候，我们会将一个对象的不同属性按不同的列进行存储。如果属性是数量不确定的数组，切记不要把这个数组属性放到新表里。

上面提到过数据操作最耗时的是磁盘数据访问，当数据量很大，多张表的磁盘查询会变得缓慢。正确的做法是将数组数据用JSON序列化，用VARCHAR或者BLOB形式存成一列，和其他数据放在同一个数据表中。

#### 6.用protobuf作为数据库的输入输出参数
这是数据库Model跨iOS、Android平台的解决方案。

两个平台用同一份proto文件分别生成各自的实现文件。

1. 需要跨平台时将数据序列化后，以传递内存的方式通过JNI接口将数据传给对方平台。
2. 对方平台有相应的方式进行反序列化。
3. JNI封装层的工作量将大大降低。

这样的好处是，后台返回protobuf的结果，网络只需要拷贝在内存的一份数据就能让数据库进行使用（实际上如果UI、DB是不同线程，可能需要两份），减少不必要的内存开支。

#### 7.不要编译使用SQLite的多线程实现
多线程版的SQLite对每行操作都加锁，性能很差，耗时为单线程版本的两倍。

## 案例
微信读书的数据库记录并不是很大，单表记录最多可能也就10w的数据级别。QQ邮箱的mailApp跟我们是用的同一套，但是数量级别远大于微信读书。目前发现的瓶颈是DB文件达到200M以上时，sqlite的性能会明显受到影响，不过具体原因还在调查中。有做过一些压力测试，用来对比CoreData，但是具体数据我这里暂时没有。
